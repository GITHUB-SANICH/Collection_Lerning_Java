public class JavaLerning {
	public void lern (){

	System.out.println("<h3>Создание фреймворка и автоматизация тестов на Java+Selenium.</h3>");
	//System.out.println("<hr><hr><hr><br><h3>Задания на тему JavaScript - Базовые понятия</h3><hr><hr><br>");
	System.out.println("<br>Урок 01: Колленкции</b></h3><hr><br>");
		//!Урок 1.1: ArrayList<> - введение
			/*
			Введение:
				ЗАМЕТКА (Минус использования ArrayList<>):
					ArrayList лучше не исползовать, если удаление и запись елементов массива производится в середине.
					Так как при удалении с серидины - элеманты справа от места удаления переносятся по индексу на 1 влево. Для данной задачи больше подходит LinkedList.
					При добавлении/удалении элеманта - под копотом создается новый массив и в него помещается старый.
					При том новый массив имеет максимальную вместимость в два раза больше относительно старого.
					Первый или последжний элемент имеют фиксированное время удаления по константе, потому их удвление на производительность не влияет.
				ЗАМЕТКА (Особенность конвенции при создании коллекци):
					Конценция имен подразумевае, что лучше объявлять коллекцию "ArrayList", ссылкясь на интерфейс List, так как он его реализует.
					Пример: List<Integer> list = new ArrayList<>();
					Так как тогда он будет иметь общий интерфейс с коллекцией "LinkedList" и в ходе работы с масисвом у объекта list можно поменять реализацию на LinkedList.
					Прмиер: list = new LinkedList<>(); ... это возможно благодаря записи "List<Integer> list". Предварительно, конечно, нужно перенести данные в новую реализацию.
			*/
		//!Урок 1.2: Устнойство ArrayList<>
			/*
				ЗАМЕТКА (устройство):
					ArrayList<> - реализует интерфейсы List, RandomAccess, Cloneable, java.io.Serializable
					Поле DEFAULT_CAPACITY = 10 отвечает за вместимость массива по дефолту. Изначально максимальный размер массивап при создании равен 10.
					Если прописать число в аргумент коллекции - это число будет предельным значением вместимости массива => List<Integer> list = new ArrayList<>(100);
			*/
		//!Урок 1.3: LinkedList - Введение
			/*
				ЗАМЕТКИ (скорость добавления):
					- LinkedList имеет такой же список методов, как и ArrayList, так как они оба имплементируют одини и те же интерфейсы.
					- При добавлении элементов в массив - linkedList работает до 2-х раз медленнее чем arrayList (200ms vs 83ms).
					Проверено через "measureTime(List<Integer> list){long start/start = System.currentTimeMillis();"}
				ЗАМЕТКИ (скорость считывания):
					- Скорость считывания большого массива в linkedList по индексу может быть в тесячу раз медленнее чем в arrayList (20023мс vs 2мс).
				ЗАМЕТКИ (скорость добвления в начло/середину):
					- Скорость добавления элемента в начало/середину массива в LinkedList быстрее в десятки раз чем в arrayList (7мс vs 485мс).
					Такая медленая скорость добавления в массив через arrayList объясняется тем, что при добавлении элемента в начало - все правые элементы переписывают интекс на +1.
					LinkedList справляется быстрее потому, что это ципочка узлов - связанные между собой объекты.
					В каждом объекте LinkedList хранится значение и ссылка на следующий объект. arrayList получает элемент быстро по индексу. LinkedList же должен же дойти до него по порядку.
			*/
		//!Урок 1.4: Связный список LinkedList - устройство
			/*
				ЗАМЕТКИ (связные списки):
					Есть два вида связанных списков: 1) односвязный - однонаправленный, 2) двусвязанный - разнонаправленный.
					Односвязный список позволяет достучаться до элемента только начиная с начала списка и до нужно го элемента.
					В то время как двусвязный не обязывает начинать с начала списка, но имеет возможность начинать отчет и с конца списка и выводятся за фиксированное время.
					LinkedList - двусвязный список, это когда элемент списка имеет ссылку на предыд  ущий и последующий элементы относительно себя. Т.е. в map не может быть дубликатов ключей.
			*/

		//!Урок 1.5: HashMap - Введение
			/*
				ЗАМЕТКИ (HashMap - структура):
					Структура HashMap - это список "корзин"/массивов, привязанных к ключам: 1 -> [... ... ... ], 2 -> [... ...], 3 -> [... ... ... ]
					К тому же HashMap - это свуязка "ключ + значение". Map<Integer, String> map = new HashMap<>(); -> Integer - тип ключа, String - тип значения.
					HashMap - своего рода ассоциотивный массив.
				ЗАМЕТКИ (методы и ключи):
					map.put(1, "Один"); - пример добавления.
					Если вставить значение с уже существующим ключом, то старое значение с переписываемым ключем - переписывается!!!
					Вместо - {1=Один, 2=Два, 3=Три}, это - {1=Один, 2=Два, 3=Другое значение для ключа три}.
					метод "get" выводи значние по-ключу. Если выводимого ключа не существует, то выводится null.
				ЗАМЕТКИ (вывод map через entry):
					for (Map.Entry<Integer, String> entry : map.entrySet()){ ... }
					Entry - имя соотношения пары ключ-значение в HashMap. Они все гда в связке и эта связка называется Entry.
					map.entrySet - это метод возврата всех пар ключ-значение в текущем HashMap.
					Это вывод ключа в entry: entry.getKey(); Это вывод значения в entry:  entry.getValue().
				ЗАМЕТКИ (HashMap - не гарантирует вывода паче ключ-значение по порядку):
					Т.е. HashMap используется, когда нет необходимости в строгом порядке вывода пар ключ-значение.
					Если же требуется, чтобы порядок в котором пары закладывались в map, то стоит использовать другие классы реализующие интерфейс Map - о них в след уроке.
			*/

		//!Урок 1.6: LinkedHashMap и TreeMap
			/*
				ЗАМЕТКИ (типы HashMap):
					LinkedHashMap - это HashMap, гарантирующий при выводе элементов порядок, тот же что и при записе.
					TreeMap - это HashMap, сортирующий элементы по ключу, в независимости от порядка записи элементов.
					HashMap - выделяется сред и двух перечисленных Map сокростью вывода и используется, когда порядок вывода не имеет значения.
		 	*/
		//!Урок 1.7: Множества Set
			/*
				ЗАМЕТКИ (типы Set):
					Set - множество, вмещающее только набор уникальных значений. Т.е. 2-х одинаковых значений в Set быть не может.
					LinkedHashSet - это HashSet, гарантирующий при выводе элементов порядок, тот же что и при записе.
					TreeSet - это HashSet, сортирующий элементы по букве (так как ключа нет в Set, в независимости от порядка записи элементов.
					HashSet - выделяется среди двух перечисленных Set сокростью вывода и используется, когда порядок вывода не имеет значения.
				ЗАМЕТКИ (методы взаимодействия множеств):
					Set имеет методы объединения множеств и вывода из них только общих значени/только различающихся/всех уникальных значений/только входящее в одно из множеств.
					Set<Integer> union = new HashSet<>(set1); - присвоение одного множества другому
					Set<Integer> intersection = new HashSet<>(set1); - присвоение одного множества другому
					Set<Integer> difference = new HashSet<>(set1); - присвоение одного множества другому
					union.addAll(set2); - объединение всех уникальных множеств
					intersection.retainAll(set2); - объединение всех уникальных пересекающихся множеств
					difference.removeAll(set2); - объединение всех уникальных значений 1-го множества, отсутствующих во 2-м множестве
				ЗАМЕТКИ (проверка на наличие - методы contains/isEmpty ... другие методы (iterator|size - в документацию)):
					contains - метод определения в множестве Set уникального значения в списке. Ворзыратщает true или false.
					Метод contains так же имеется и в массиве ArrayList, однако, работает на порядок медленне чем в Set.
					Поэтому если не важен порядок хранения уникальных элементов лучше использовать HashSet.
					isEmpty - метод определения в множестве Set отсутствия уникального значения в списке (противоположный contains). Ворзыратщает true или false.
				ЗАМЕТКИ (обработка дубликатов):
					при попытке присвоения дубликата к Set - он игнарирутеся
					Так же множество Set выводится чреез "System.out.println();", так как Set реализует метод "toString".
		 	*/

		//!Урок 1.8: Методы hashcode и equals
			/*
				ЗАМЕТКИ (hashcode и equals):
					Это важная тема, так как приблизит к пониманию устройства и работы HashMap и HashSet, а так же пониманию хеширования и контрактов.
					Методы hashcode и equals
					Ключи в классах реализующих интерфейс Map - уникальны. Так же элементы Set - уникальны.
					Т.е. если перезаписать ключ в map - он перезапишится без дубляжа.
					Т.е. если перезаписать значение set - останется только орегинал.
					Значит map и set как то определяет, что при присвоении, что вводимые данные уже имеются в массиве/множестве.
				ЗАМЕТКА (НЕЛЬЗЯ пинимать в Set и Map в виде аргументов объекты => Map<Person, String> | Set<Person>):
					ВАЖНО!  Set и Map принимают в качестве аргументов обортки для приметивом (Integer|String, а не int).
					Так как если принять объект класса  в Set или Map есть вероятность вместить два объекта с идентичными значениями.
					И тогда Set будет иметь два идентичных значения и Map два одинаковых ключа с одинаковыми значениями!
					Пример:
						Person person1 = new Person(1, "Make");
				        Person person2 = new Person(2, "Katy");
				        ...
						Person person1 = new Person(1, "Make");
				        Person person2 = new Person(1, "Make");
						map.put(person1, "123");
						map.put(person2, "123");
						set.add(person1);
						set.add(person2);
						System.out.println("map: "+map);
						System.out.println("set: "+set);
					Рузультат встувки объекта с разными значениями:
						map: {Person{id=2, name'Katy'}=123, Person{id=1, name'Make'}=123}
				        set: [Person{id=2, name'Katy'}, Person{id=1, name'Make'}]
					Рузультат встувки объекта с одним и тем же значением:
						map: {Person{id=1, name'Make'}=123, Person{id=1, name'Make'}=123}
						set: [Person{id=1, name'Make'}, Person{id=1, name'Make'}]
				ЗАМЕТКИ (причина будлирования):
					Это дублирование не происходит с использованием типов <Integer, String>, так как классы Integer и String реализуют метод hashcode и equals.
					Пример:
						Integer i = 10; String s = "str";
						s.equals("str"); s.hashCode();
						i.equals(4); i.hashCode(4);
				ЗАМЕТКИ (способ исправления ошибки с объектом):
					При использовании в качестве аргумента сторонний класс - в нем нужно явно реализовать методы hashcode и equals.
					В примере ниже теперь сравнение объектов идет по из полям.
					Пример:
						@Override
						public boolean equals(Object o) {
							if (this == o) return true;
							if (o == null || getClass() != o.getClass()) return false;

							Person person = (Person) o;

							if (id != person.id) return false;
							return name.equals(person.name);
						}

						@Override
						public int hashCode() {
							int result = id;
							result = 31 * result + name.hashCode();
							return result;
						}

					Рузультат верной работы Set и Map при переопределении методов hashcode и equals в объекте:
						map: {Person{id=1, name'Make'}=123}
						set: [Person{id=1, name'Make'}]
						Теперь добавление одинаковых ключей и значений не произашло.
				ЗАМЕТКА (сравнивать строки через оператор "==" - неправильно, так как может возвратщаться false, если строки указывают на разные участки памяти):
				ЗАМЕТКИ (equals):
					Метод equals наследуется от класса object и занимается проверкой данных внутри одной ячейки памяти. Создаваемые объекты всегда занимают разные ячейки памяти.
					Поэтому два разных объекта с одинаковыми данными, будут считаться мектодом equals как одно и тоже.


		//!Урок 1.9: Контракт hashcode и equals
			/*
				ЗАМЕТКИ (Принцип работы hashcode):
					Хеширование - это преобразование массива входных данных произвольной длинны в выходную строку фиксированной длинны.
					Функция, реализующая преобразование называется хеш функцией или функцией свёртки.
					Ключевое: преобразование чего либо произвольной длинны во что-то фиксированной длинны.
					hashcode конвертирует объект в целое число в зависимости от полей, содержащихся в объекте : {object} => {int}
					Это делается, потому, что сравнивать целые числа проще чем объекты - т.е. если хеш у объектов разный (результат конвертации разных полей в int), то объекты уже точно разные.
					Можно сказать что хеш - это упрощенная версия объекта по которой сравнивать проще всего.
					hashcode - наиболее быстрый способ сравнения. Так как сравнивать объекты через сравнение всех их полей долго - проще сконвертировать все поля в число и сравнивать уже его.
					Однако если хеш объектов равный, то тогда приходится сравнивать их через equals.
					hashcode может быть равным так как хеш ограничин в генерируемым максимальном числе.
					Число это тип данных int, значит генерируемое число не будет привышать 32 бита, значит сравниваемые объекты просто могут упереться в потолок генерируемых чисел.
				ЗАМЕТКА (КоллИзия - ситуация, получаемая когда сравниваемый хеш разных объектов совпадает)
				ЗАМЕТКА (ХЕШ расчитывается на основании полей)
					Тут то и нужен equals - если проверка через hashcode не прошла.
					Но если объекты не равны по hashcode, то по equals - их сравнивать смысла нет - они уже не будет равны.
					Если equals сравнивает в элементы в рамках ячейки памяти, то hashcode сравнивает конвертируемое число объектов.
					hashcode и equals - оба обязательны для проверки объектов на равенство или неравенство.
				ЗАМЕТКИ (Контракт hashcode и equals):
					1) У двух вызываемых сравниваемых объектов вызываем метод hashcode()
					2)  Если хеш одинаковый при их сравнении, то подключается проверка через метод equals(). Если хеш разных, то метод equals() не вызывается.
					3) equals() уже наверняка скажет, объекты одинаковые или разные.

				ЗАМЕТКИ (когда нужно переопределять hashcode и equals методы):
					Тогда, когда аргументом выступает объект самописного класса.
					Так как объекты классов Integer и String - уже автоматически используют hashcode и equals методы в map и set коллекциях.
		 	*/

		//!Урок 1.10: HashMap - Как устроен
			/*
				ЗАМЕТКИ (почему рассматриваем HashMap, а не HasSet? Так как HasSet - это обрубленый HashMap):
					В Java HashSet в своей реализации использует HashMap.
					Так как HashSet хранит в себе тоько уникальные значения. А в HashMap уникальыне ключи в одном экземпляре.
					В общем HashSet не имеет собственной реализации. HashSet операется на HashMap.
					HashSet - это HashMap с обрубленными ключами, в котором остались только значения. И если залезть под копот HashSet - то видно что при его создании создается HasMap.
				ЗАМЕТКИ (реализация HashMap):
					HashMap внутри себя использует массив. В нем мы может быстро обращаться к его элементам по индексу.
					В каждой ячейке массива хранится связный список. Т.е. HashMap хранит внутри себя массив связных списков или массив из LinkedList<>.
					Такая конструкция позволяет быстро выполнять операции put и get (добавления и вывода).
				ЗАМЕТКИ (содержимое узлов массива HashMap):
					1) int hash - хел элемента;
					2) K key - ключ ячейки;
					3) V value - значение ячейки;
					4) Node<K, V> next - ссылка на следующий узел;
					Все это похоже на связнй список LinkedList<> - впринципе так и есть;
					При вызове метода "put" (scores.put("KING", 100);) у нового ключа будет посчитан hash (не важно это строка или число).
					ПОЭТОМУ у каждого класса, объект которого выступает как содеримое hashMap - должен быть реализован метод hashCode, возвратщающий hash для адекватной работы массива.
					hash слишком велик для присвоения его окак ключа. Но он должен содержаться в индексе.
					Интекс создается по принципу => index = hash & (n-1), где n - максимальное число элементов массива -1 == интекс.
					Результатом таколо побитого сложения является остаток деления равный рандомному числоу от 0 до MAX вместимости массива.
					Мы же помним, что в hashMap порядок не имеет значения, поэтому запись производится не по строгому порядку (первый добавляемый элемент не обязательно 1-й по индексу).
					Т.е. индекс это результат побитого умножения  между хешом и максимально возможным интеком массива на момент добавления элемента.
					По другому эту операцию можно назвать как поулчение остатка от целочисленного деления - деление hash/(n-1) - большого числа на малое.
					Этот остаток гарантированна помещается в рамках предела массива.
					Поэтому если ключом ячейки является строка ли, что число ли - все перемешивается в хеш, а потом перегоняется в одно из свободных ячеек в массиве map.
					Поэтому в map - не имеет значения какого типа ключа.
					Если добавленный элемент единственный в массиве, то его ссылка на след элемент равняется NULL.
				ЗАМЕТКИ (результат побитного умножения дал одинаковое число (индекс) при разных хешах):
					Если интекс (номер генерируемой ячейки) двух элементов, полученный в результате побитного сложения хеша и макс индекса в массиве оказался одинаковым,
					 то 2-й элемент помещается в ту же ячейку, но с другим хешем и ключом и первый элемент будет иметь ссылку на второй - будут связан.
				ЗАМЕТКИ (операция map.get и проверка хешей и ключей):
					Этапы получения элемента по ключу через метод map.get():
					 	1) Обращение к индексу (ячейке). Если ячейка имеет только одно значение - оно возвратщается.
					 	2) Если в одной ячейке несколько пачек (ключ+значение), то идет поиск внутри ячейки по хешу.
					 	3) Если хеш найден и он равен тому, что есть в ячейке, то идет сравнение ключей в пачке через метод equals(). Если ключи равны, то выводится значение.
					 	Проверка ключей через метод equals() нужна как перестраховка от коллИзии хеша.
					HashMap по скорости получения элемента не уступает ArrayList, так как поиск начинается с определенной ячейки и далее по хешу/ключу.
				ЗАМЕТКИ (что если все пары (ключ+значние) будет находиться в одной ячейке?):
					Если все пары (ключ+значние) будет находиться в одной ячейке, то это уже будет не маасив HashMap, а LinkedList.
		 	*/

		//!Урок 1.11: Интерфейс Comparator
			/*
				ЗАМЕТКИ (сортировка объектов в java-collection):
					Интерфейс Comparator - это инструмент сортировки внутри масивов.
					На уроках с разбором Comparator будут использоваться массивы, сохраняющие в себе порядок (ArrayLis, LinkedList, TreeMap, LinkedHashMap)
						Collections.sort(array); - сортировка происходит по числу от меньшего к большему, либо строк по алфавиту (т.е. по лексико-графическому порядку).
						Естественный порядко - сортировка по лексико-графическому порядку или от меньшего числа к большему.
					Пример сортировки коллекции:
						List<Integer> numbers = new ArrayList<>();
						numbers.add(3); numbers.add(2);
						Collections.sort(numbers); return {2, 3};
				ЗАМЕТКИ (кастомная логика сортировки объектов):
					Однако, можно внести свою логику сортировки. Например сортировка строк по их длинне.
					Самописная логика сортировка может прописываться в классе за счет интерфейса Comparator.
					Comparator - это так же и класс исплементирующий интерфейс Comparator, т.е. с измененной логикой сортировки.
					В интерфейсе Comparator существует только один метод ().
					Объекты класса имплементирующего Comparator будут сортироваться по сапомиснгой логике, игнорируя естественный порядок.
					После объект этого класса передается в метод Collections.sort(), применяя уже свою логику сортировки.
					Интерфейс Comparator параметризирован, поэтому при имплементации нужно указать пораметр по которому будут происходить сравнения.
					Пример:
						public static class Comparator implements java.util.Comparator<String>{ ... }
				ЗАМЕТКИ (логика сортировки метода compare()):
					Чтобы Java понимала, как сравнивать объекты метод compare() возвратщает 1/0/-1 при разных условиях, и по этим числа определяет как отсортировывать объекты.
					o1.length() > o2.length() => 1; Objects.equals(o1.length(), o2.length()) => 1; o1.length() < o2.length() => -1;
					Далее объект с логикой сортировки добавляется в метод сортировки как дополнительный аргумент => Collections.sort(numbers, new StringLengthComparator());
				ЗАМЕТКИ (использование анонимных классов для логики сортировки):
					Создание отдельного класса для написания логики осртировки - жирно будет.
					Поэтому лучше сразу в моменте вызова сортировки создать анонимный класс, имплементирующий Comparator. Название класса будет Comparator<type>{@Override ... compare(){}}
					Пример:
						Collections.sort(integers, new Comparator<Integer>(){
							@Override
							public int compare(Integer o1, Integer o2) {
								if (o1 > o2){
									return -1;
								}else if (Objects.equals(o1, o2)){
									return 0;
								}else{
									return 1;
								}
							}
						});
					С лямбто вырожением код порлучается еще короче.
					Пример:
						Collections.sort(integers, (o1, o2) -> {
							if (o1 > o2){
								return -1;
							}else if (Objects.equals(o1, o2)){
								return 0;
							}else{
								return 1;
							}
						});
				ЗАМЕТКИ (правила сортировки самолписных объектов):
					При создании класса пользователя с именем и id - при попытки сортировать объекты класса будет выводится ошибка.
					Так как по-умолчанию в сторонних объектах не задан естественный порядок/лексико-графический. С String и Integer сортировка уже прилогается.
					Пример сортировки пользователей по ID:
						Collections.sort(people, (o1, o2) -> {
							if (o1.getId() < o2.getId()){
								return 1;
							} else if (o1.getId() > o2.getId()) {
								return -1;
							}else {
								return 0;
							}
						});
					Так выглядет еще более сокращенный способ сортировки через компаратор с использованием лямбта.
					Пример:
						people.sort((o1, o2) -> {
							return Integer.compare(o2.getId(), o1.getId());
						});
					А вот самый сокращенный способ сортировки по естественному порядку.
					Пример:
						people.sort((o1, o2) -> Integer.compare(o2.getId(), o1.getId()));
					Или так в случаи у естественного, а не обратного порядка:
						people.sort(Comparator.comparingInt(Person::getId));
		 	*/


		//!Урок 1.12: Интерфейс Comparable
			/*
				ЗАМЕТКИ (попытка сортировки объектов):
					Естественный порядок сортировки был доступен только для встроенных классов String|Integer - для самописных правила писались самостоятельно через Comparator.
					Создадим класс Human и добавим в него методы toString() и hashCode()|equals().
					Добавим конструктор, устанавливающий ID и name.
					Создадим 2 колекции и попытаемся добавить в них объекты и отсортировать:
						List<Human> humanList = new ArrayList<>(); Set<Human> humanSet = new TreeSet<>();
					Пример:
						private void addElements(Collection collections){
							collections.add(new Human(1, "FirstHumanName"));
							collections.add(new Human(2, "TwoHumanName"));
						}
					Выведется ошибка, так как добавляемый объект не имеет понятия естественного числового или лексико-графического порядка.
					Если же закоментирвать TreeSet, и оставим только List? то ошибки не будет. List не сортируется по-умолчанию.
					Но при попытки сортировки List'а через Collections.sort(humanList); - ошибка снова появится, так как это снова попытка сортировки.
				ЗАМЕТКА(настройка естественного порядка сортировки самописному классу):
					Чтобы дать понять Jav'e, что объекты сортируемы - т.е. на них определен какой то порядок сортировки.
					Для этого в классе объекты которого нужно отсортировать имплементируется интерфейс "Comporoble":
					public class Human implements Comparable<Human>{...}
					ВАЖНО! Если в прошлом уроке класс имплементировал интерфейс "Comparator" - он задавал правила сортировки объекта.
						И реализовывал методы-правила сравнения объектов класса имплементирующего "Comparator".
						И сравнение объектов проходили внутри класса.
						Comparable же при имплементации - позволяет сортироваться объектам класса по числовому или лексико-графическому порядку в сторонних методах. Например в "sort".
						Comparable дословно переводитс - сравниваемый или способный быть сравниваемым. Comparator же - сравнивающий.
					Этот интерфейс как и Comparator<Integer> - тоже параметризован => Comparable<Human>.
					При имплементации интерфейсав классе повялвятся метод:
						@Override
						public int compareTo(Human o) {
							return 0;
						}
						Метод подразумевает сравнение объекта "Human" с другим объектом "Human" через сторонние методы.
						Правила сортировки в этом методе переписывается. Этот метод и вмещает правила сортировки так же как и интерфейс Comparator.
						Пример правила сортировки объектов по-порядку:
							public int compareTo(Human o) {
								if (this.id < o.getId()){
									return -1;
								} else if (this.id > o.getId()) {
									return 1;
								}else {
									return 0;
								}
							}
							или
							public int compareTo(Human o) {
								return Integer.compare(this.id, o.getId());
							}
					Метод сортировки же вызывается через "Collections.sort(humanList);" и все нормально работает.
					Для Comparator пришлось бы добавлять вложенный класс с правилом сортировки или вызывать метод с правилом сортировки.
					По такому же принциппу можно пропистаь правило сортировки по длинне имени, но аналог был написан на компоратор. Поэтому суть и так ясна.

		 	*/

		//!Урок 1.13: Очередь Queue
			/*
				ЗАМЕТКИ (очередь тоже коллекция):
					Очедерь (Queue) это коллекция, в которую записывается очередность элементу по принцыпу "1-й зашел = 1-й вышел".
					Очереди используются часто там, где есть многопоточность - поток, что пришел раньше всех должен получить доступ к ресурсу раньше всех.
				ЗАМЕТКИ (реализация интерфейсов Queue через LinkedList):
					Queue реализует интерфейсы LinkedList и PriorityQueue. О PriorityQueue говорить не будем - это специфическая вещь хотя там нет ничего сложного.
					Создадим список объектов - людей: Human human1 = new Human(1, "one"); и т.д.
					Создадим коллекцию - очередь: Queue<Human> humans = new LinkedList<>();
					Добавим люедй в нее - humans.add(human3); и т.д.
					Выведем ее - for (Human human : humans) System.out.println("Хумы из очереди: "+human); ... все люди выводятся по порядку записи в коллекцию.
				ЗАМЕТКИ (реализация интерфейсов Queue через ArrayBlockingQueue):
					ArrayBlockingQueue - используется особенно часто в многозадачности, где требуется ввод ограничение к ресурсу.
					ArrayBlockingQueue позволяет в отличии от LinkedList задавать предельное число в очереди.
					Queue<Human> humans_blocking = new ArrayBlockingQueue<>(10);
					В случаи добавления элемента привышающего заданный лимит очереди - может выводиться exception, при использовании нужного метода добавления.
				ЗАМЕТКИ (разница в методах добавления в очередь, удаления из очереди, вывода из очереди):
					peek() - вывод первого элемента очереди.
					remove() - удаление первого элемента из очереди.
					Различия между парами методов:
						1) add(e) | offer(e) - добавляют элементы в очередь.
						2) remove() | poll() - забирают элементы из очереди.
						3) element() | peek() - показывают первый элемент из очереди.
					Однако, методы add(e) | remove() | element() - выбразывают exception в случаи ошибки.
					А методы offer(e) | poll() | peek() - возвратщают специальные значение в случаи ошибки. Либо просто не выполняются не выбрасывая исключения при компиляции.
					Например при добавлении элемента в очередь если лимитное число значений в очереди уже достигнуто.
		 	*/

		//!Урок 1.14: Стек Stack
			/*
				ЗАМЕТКИ (Stack это тоже коллекция):
					Stack это тоже коллекция, реализующая интерфейс List и на следующаяся от класса Vector.
					Vector мы не будем разбирать, так как этот класс устаревший. Раньше до появления ArrayList - он выполнял его функцию. Теперь Vector не используется.
					Stack параметризован => Stack<Integer> stack = new Stack<>();
				ЗАМЕТКИ (Класс Stack это полная противоположность очередям Queue):
					Класс Stack это полная противоположность очередям Queue, так как те работают по принципу - "первызашел-первый вышел".
					Stack работает по принципу "последний зашел-первый вышел". Как в банку с помидорами - последний положил-первый достал)
				ЗАМЕТКИ (методы класса Stack):
					push() - добавляет элемент в стек. push переводится как продавливать/заталкивать/жать. push() похож на метод add().
					pop() - метод извлекающий последний добавленный элемент из стека. Т.е. pop() в Stack как и remove() в Queue - не удаляет, но извлекает.
					Если извлечены все элеменыт методом pop(), то выдается exception, что в стеке не осталось элементов.
					peek() - выводит последний элемент массива, оставляя его неа месте.
					empty() - возвратщает boolean если Stack пустой == true или false == непустой.
					Пример исползования:
						while (!stack.empty()){
							System.out.println(stack.pop());
						}
						Пока коллекция stack не пуста - выводить элемент через метод pop().

		 	*/

		//!Урок 1.15: Интерфейс Iterable
			/*
				ЗАМЕТКИ (Интерфейс Iterable и метод iterable):
					В предыдущих уроках элементы колелкций проверялись методами hashCode()|equals()System, а так же метод compareTo() для сортировки элементов в коллекциях.
					Интерфейс Iterable - это интерфейс, реализуемый всеми коллекциями, позволяемый переберать все элементы коллекции через цикл foreach() == for(int x: list).
					меотд iterable() - это метод с настройкой перебора элементов в объекте-коллекции.
					Используется, когда нужно, чтобы перебор коллекции проходил по нестандартной логике. На практике это не нужно так часто.
					Т.е. цикл foreach под копотом использует Iterator - Интерфейс позволяющие реулизующим его объектам быть перебераемыми.
					Iterator напрямую использовался в 5-й версии Java. У объекта реулизующего Iterator появляютс методы перебора коллекции.
					Сейчас прямого взаимодействия с Iterator не требуется так как foreach обеспечивает абстракцию над иттератором.
					Пример использования иттератора в 5-й версии:
						List<Integer> list = new ArrayList<>();
						list.add(1); list.add(2); list.add(3);
						for (int x : list) System.out.println("Вывод элемента: "+x);
						Iterator<Integer> iterator = list.iterator();
						while (iterator.hasNext())
							System.out.println("Вывод элементов через иттератор: "+iterator.next());
				ЗАМЕТКИ (как работает итератор):
					Итератор хранит в себе указатель на элемент объекта. При создании итератора - он указывает на пространство перед 1-м элементом объекта - т.е. перед первым элементом.
					При вызове итератора - он перемещается на следующий элемент (т.е. на 1-й) и так до последнего.
				ВАЖНО! Итератор дает приемущество в том, что он может удалять элементы во время итерации, в то время как foreach() не может этого делать.
					Удаление элемента из foreach() можжет привести к неопределенному состоянию - потому проектировщики Java запретили удалать элемент при переборе foreach().
					Т.е. при удалении элемента через foreach() - цикл не будет знать, что показывать-выводить дальше. Поэтому удаление чреез foreach() вжесткую запретили.
					Iterator же хранит указания на все элементы при переборе (т.е. удяляется только указанный элемент), потому удаление элемента через итератор прогнозируемо.

		 	*/
	}
}